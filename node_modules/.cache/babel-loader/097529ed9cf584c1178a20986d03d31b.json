{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribeOn = void 0;\n\nvar lift_1 = require(\"../util/lift\");\n\nfunction subscribeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return lift_1.operate(function (source, subscriber) {\n    subscriber.add(scheduler.schedule(function () {\n      return source.subscribe(subscriber);\n    }, delay));\n  });\n}\n\nexports.subscribeOn = subscribeOn;","map":{"version":3,"mappings":";;;;;;;AACA;;AA6DA,SAAgBA,WAAhB,CAA+BC,SAA/B,EAAyDC,KAAzD,EAA0E;AAAjB;AAAAA;AAAiB;;AACxE,SAAOC,eAAQ,UAACC,MAAD,EAASC,UAAT,EAAmB;AAChCA,cAAU,CAACC,GAAX,CAAeL,SAAS,CAACM,QAAV,CAAmB;AAAM,mBAAM,CAACC,SAAP,CAAiBH,UAAjB;AAA4B,KAArD,EAAuDH,KAAvD,CAAf;AACD,GAFM,CAAP;AAGD;;AAJDO","names":["subscribeOn","scheduler","delay","lift_1","source","subscriber","add","schedule","subscribe","exports"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/operators/subscribeOn.ts"],"sourcesContent":["import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n"]},"metadata":{},"sourceType":"script"}