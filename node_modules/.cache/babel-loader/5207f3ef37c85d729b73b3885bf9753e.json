{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bufferTime = void 0;\n\nvar Subscription_1 = require(\"../Subscription\");\n\nvar lift_1 = require(\"../util/lift\");\n\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\n\nvar arrRemove_1 = require(\"../util/arrRemove\");\n\nvar async_1 = require(\"../scheduler/async\");\n\nvar args_1 = require(\"../util/args\");\n\nvar executeSchedule_1 = require(\"../util/executeSchedule\");\n\nfunction bufferTime(bufferTimeSpan) {\n  var _a, _b;\n\n  var otherArgs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    otherArgs[_i - 1] = arguments[_i];\n  }\n\n  var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;\n  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  var maxBufferSize = otherArgs[1] || Infinity;\n  return lift_1.operate(function (source, subscriber) {\n    var bufferRecords = [];\n    var restartOnEmit = false;\n\n    var emit = function emit(record) {\n      var buffer = record.buffer,\n          subs = record.subs;\n      subs.unsubscribe();\n      arrRemove_1.arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    var startBuffer = function startBuffer() {\n      if (bufferRecords) {\n        var subs = new Subscription_1.Subscription();\n        subscriber.add(subs);\n        var buffer = [];\n        var record_1 = {\n          buffer: buffer,\n          subs: subs\n        };\n        bufferRecords.push(record_1);\n        executeSchedule_1.executeSchedule(subs, scheduler, function () {\n          return emit(record_1);\n        }, bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n    var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n      var e_1, _a;\n\n      var recordsCopy = bufferRecords.slice();\n\n      try {\n        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n          var record = recordsCopy_1_1.value;\n          var buffer = record.buffer;\n          buffer.push(value);\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }, function () {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, function () {\n      return bufferRecords = null;\n    });\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n\nexports.bufferTime = bufferTime;","map":{"version":3,"mappings":"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","names":["bufferTime","bufferTimeSpan","otherArgs","scheduler","_a","async_1","bufferCreationInterval","_b","maxBufferSize","Infinity","lift_1","source","subscriber","bufferRecords","restartOnEmit","emit","record","subs","unsubscribe","arrRemove_1","next","buffer","startBuffer","Subscription_1","add","record_1","push","executeSchedule_1","bufferTimeSubscriber","OperatorSubscriber_1","value","recordsCopy","slice","recordsCopy_1_1","length","shift","complete","undefined","subscribe","exports"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/operators/bufferTime.ts"],"sourcesContent":["import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n"]},"metadata":{},"sourceType":"script"}