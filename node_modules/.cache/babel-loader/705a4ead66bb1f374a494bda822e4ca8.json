{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeInternals = void 0;\n\nvar innerFrom_1 = require(\"../observable/innerFrom\");\n\nvar executeSchedule_1 = require(\"../util/executeSchedule\");\n\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\n\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n  var buffer = [];\n  var active = 0;\n  var index = 0;\n  var isComplete = false;\n\n  var checkComplete = function checkComplete() {\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  var outerNext = function outerNext(value) {\n    return active < concurrent ? doInnerSub(value) : buffer.push(value);\n  };\n\n  var doInnerSub = function doInnerSub(value) {\n    expand && subscriber.next(value);\n    active++;\n    var innerComplete = false;\n    innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) {\n      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n\n      if (expand) {\n        outerNext(innerValue);\n      } else {\n        subscriber.next(innerValue);\n      }\n    }, function () {\n      innerComplete = true;\n    }, undefined, function () {\n      if (innerComplete) {\n        try {\n          active--;\n\n          var _loop_1 = function _loop_1() {\n            var bufferedValue = buffer.shift();\n\n            if (innerSubScheduler) {\n              executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function () {\n                return doInnerSub(bufferedValue);\n              });\n            } else {\n              doInnerSub(bufferedValue);\n            }\n          };\n\n          while (buffer.length && active < concurrent) {\n            _loop_1();\n          }\n\n          checkComplete();\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }\n    }));\n  };\n\n  source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function () {\n    isComplete = true;\n    checkComplete();\n  }));\n  return function () {\n    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n  };\n}\n\nexports.mergeInternals = mergeInternals;","map":{"version":3,"mappings":";;;;;;;AACA;;AAGA;;AACA;;AAeA,SAAgBA,cAAhB,CACEC,MADF,EAEEC,UAFF,EAGEC,OAHF,EAIEC,UAJF,EAKEC,YALF,EAMEC,MANF,EAOEC,iBAPF,EAQEC,mBARF,EAQkC;AAGhC,MAAMC,MAAM,GAAQ,EAApB;AAEA,MAAIC,MAAM,GAAG,CAAb;AAEA,MAAIC,KAAK,GAAG,CAAZ;AAEA,MAAIC,UAAU,GAAG,KAAjB;;AAKA,MAAMC,aAAa,GAAG,SAAhBA,aAAgB;AAIpB,QAAID,UAAU,IAAI,CAACH,MAAM,CAACK,MAAtB,IAAgC,CAACJ,MAArC,EAA6C;AAC3CR,gBAAU,CAACa,QAAX;AACD;AACF,GAPD;;AAUA,MAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAS;AAAK,WAACP,MAAM,GAAGN,UAAT,GAAsBc,UAAU,CAACD,KAAD,CAAhC,GAA0CR,MAAM,CAACU,IAAP,CAAYF,KAAZ,CAA3C;AAA8D,GAA9F;;AAEA,MAAMC,UAAU,GAAG,SAAbA,UAAa,CAACD,KAAD,EAAS;AAI1BX,UAAM,IAAIJ,UAAU,CAACkB,IAAX,CAAgBH,KAAhB,CAAV;AAIAP,UAAM;AAKN,QAAIW,aAAa,GAAG,KAApB;AAGAC,0BAAUnB,OAAO,CAACc,KAAD,EAAQN,KAAK,EAAb,CAAjB,EAAmCY,SAAnC,CACEC,8CACEtB,UADF,EAEE,UAACuB,UAAD,EAAW;AAGTpB,kBAAY,SAAZ,gBAAY,WAAZ,GAAY,MAAZ,eAAY,CAAGoB,UAAH,CAAZ;;AAEA,UAAInB,MAAJ,EAAY;AAGVU,iBAAS,CAACS,UAAD,CAAT;AACD,OAJD,MAIO;AAELvB,kBAAU,CAACkB,IAAX,CAAgBK,UAAhB;AACD;AACF,KAfH,EAgBE;AAGEJ,mBAAa,GAAG,IAAhB;AACD,KApBH,EAsBEK,SAtBF,EAuBE;AAIE,UAAIL,aAAJ,EAAmB;AAKjB,YAAI;AAIFX,gBAAM;;;AAMJ,gBAAMiB,aAAa,GAAGlB,MAAM,CAACmB,KAAP,EAAtB;;AAIA,gBAAIrB,iBAAJ,EAAuB;AACrBsB,gDAAgB3B,UAAhB,EAA4BK,iBAA5B,EAA+C;AAAM,iCAAU,CAACoB,aAAD,CAAV;AAAyB,eAA9E;AACD,aAFD,MAEO;AACLT,wBAAU,CAACS,aAAD,CAAV;AACD;;;AATH,iBAAOlB,MAAM,CAACK,MAAP,IAAiBJ,MAAM,GAAGN,UAAjC,EAA2C;;AAU1C;;AAEDS,uBAAa;AACd,SAtBD,CAsBE,OAAOiB,GAAP,EAAY;AACZ5B,oBAAU,CAAC6B,KAAX,CAAiBD,GAAjB;AACD;AACF;AACF,KA1DH,CADF;AA8DD,GA9ED;;AAiFA7B,QAAM,CAACsB,SAAP,CACEC,8CAAyBtB,UAAzB,EAAqCc,SAArC,EAAgD;AAE9CJ,cAAU,GAAG,IAAb;AACAC,iBAAa;AACd,GAJD,CADF;AAUA,SAAO;AACLL,uBAAmB,SAAnB,uBAAmB,WAAnB,GAAmB,MAAnB,sBAAmB,EAAnB;AACD,GAFD;AAGD;;AAhIDwB","names":["mergeInternals","source","subscriber","project","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","active","index","isComplete","checkComplete","length","complete","outerNext","value","doInnerSub","push","next","innerComplete","innerFrom_1","subscribe","OperatorSubscriber_1","innerValue","undefined","bufferedValue","shift","executeSchedule_1","err","error","exports"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/operators/mergeInternals.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n"]},"metadata":{},"sourceType":"script"}