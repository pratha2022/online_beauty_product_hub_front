{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.timeoutWith = void 0;\n\nvar async_1 = require(\"../scheduler/async\");\n\nvar isDate_1 = require(\"../util/isDate\");\n\nvar timeout_1 = require(\"./timeout\");\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  var first;\n  var each;\n\n  var _with;\n\n  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;\n\n  if (isDate_1.isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = function _with() {\n      return withObservable;\n    };\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout_1.timeout({\n    first: first,\n    each: each,\n    scheduler: scheduler,\n    with: _with\n  });\n}\n\nexports.timeoutWith = timeoutWith;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AA+EA,SAAgBA,WAAhB,CACEC,GADF,EAEEC,cAFF,EAGEC,SAHF,EAG2B;AAEzB,MAAIC,KAAJ;AACA,MAAIC,IAAJ;;AACA,MAAIC,KAAJ;;AACAH,WAAS,GAAGA,SAAS,SAAT,aAAS,WAAT,eAAaI,aAAzB;;AAEA,MAAIC,qBAAYP,GAAZ,CAAJ,EAAsB;AACpBG,SAAK,GAAGH,GAAR;AACD,GAFD,MAEO,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAClCI,QAAI,GAAGJ,GAAP;AACD;;AAED,MAAIC,cAAJ,EAAoB;AAClBI,SAAK,GAAG;AAAM;AAAc,KAA5B;AACD,GAFD,MAEO;AACL,UAAM,IAAIG,SAAJ,CAAc,qCAAd,CAAN;AACD;;AAED,MAAIL,KAAK,IAAI,IAAT,IAAiBC,IAAI,IAAI,IAA7B,EAAmC;AAEjC,UAAM,IAAII,SAAJ,CAAc,sBAAd,CAAN;AACD;;AAED,SAAOC,kBAA+B;AACpCN,SAAK,OAD+B;AAEpCC,QAAI,MAFgC;AAGpCF,aAAS,WAH2B;AAIpCQ,QAAI,EAAEL;AAJ8B,GAA/B,CAAP;AAMD;;AAjCDM","names":["timeoutWith","due","withObservable","scheduler","first","each","_with","async_1","isDate_1","TypeError","timeout_1","with","exports"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/operators/timeoutWith.ts"],"sourcesContent":["import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nimport { timeout } from './timeout';\n\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n\n/**\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\n * and switch the subscription to another observable.\n *\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\n *\n * Useful in cases where:\n *\n * - You want to switch to a different source that may be faster.\n * - You want to notify a user that the data stream is slow.\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\n *   by the default usage of {@link timeout}.\n *\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\n * it will unsubscribe from the source and switch the subscription to another observable.\n *\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\n *\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\n * the `first` configuration to get the same effect.\n *\n * ## Examples\n *\n * Fallback to a faster observable\n *\n * ```ts\n * import { interval, timeoutWith } from 'rxjs';\n *\n * const slow$ = interval(1000);\n * const faster$ = interval(500);\n *\n * slow$\n *   .pipe(timeoutWith(900, faster$))\n *   .subscribe(console.log);\n * ```\n *\n * Emit your own custom timeout error\n *\n * ```ts\n * import { interval, timeoutWith, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(1000);\n *\n * slow$\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\n *   .subscribe({\n *     error: err => console.error(err.message)\n *   });\n * ```\n *\n * @see {@link timeout}\n *\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\n * @param withObservable The observable to switch to when timeout occurs.\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it starts emitting values\n * from the `ObservableInput` passed as a second parameter.\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\n */\nexport function timeoutWith<T, R>(\n  due: number | Date,\n  withObservable: ObservableInput<R>,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T | R> {\n  let first: number | Date | undefined;\n  let each: number | undefined;\n  let _with: () => ObservableInput<R>;\n  scheduler = scheduler ?? async;\n\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = () => withObservable;\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout<T, ObservableInput<R>>({\n    first,\n    each,\n    scheduler,\n    with: _with,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}