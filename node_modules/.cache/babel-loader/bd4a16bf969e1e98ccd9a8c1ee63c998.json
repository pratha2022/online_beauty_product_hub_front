{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {\n    to[j] = from[i];\n  }\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.raceWith = void 0;\n\nvar race_1 = require(\"../observable/race\");\n\nvar lift_1 = require(\"../util/lift\");\n\nvar identity_1 = require(\"../util/identity\");\n\nfunction raceWith() {\n  var otherSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    otherSources[_i] = arguments[_i];\n  }\n\n  return !otherSources.length ? identity_1.identity : lift_1.operate(function (source, subscriber) {\n    race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);\n  });\n}\n\nexports.raceWith = raceWith;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AA4BA,SAAgBA,QAAhB,GAAwB;AACtB;;OAAA,yCAA6C;AAA7CC;;;AAEA,SAAO,CAACA,YAAY,CAACC,MAAd,GACHC,mBADG,GAEHC,eAAQ,UAACC,MAAD,EAASC,UAAT,EAAmB;AACzBC,oBAAQC,eAAiBH,MAAjB,GAAuBI,OAAKR,YAAL,CAAvB,CAAR,EAAmDK,UAAnD;AACD,GAFD,CAFJ;AAKD;;AARDI","names":["raceWith","otherSources","length","identity_1","lift_1","source","subscriber","race_1","__spreadArray","__read","exports"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/operators/raceWith.ts"],"sourcesContent":["import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { raceInit } from '../observable/race';\nimport { operate } from '../util/lift';\nimport { identity } from '../util/identity';\n\n/**\n * Creates an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of the Observable to which\n * the operator is applied and supplied Observables.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, raceWith } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * obs1\n *   .pipe(raceWith(obs2, obs3))\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param otherSources Sources used to race for which Observable emits first.\n * @return A function that returns an Observable that mirrors the output of the\n * first Observable to emit an item.\n */\nexport function raceWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return !otherSources.length\n    ? identity\n    : operate((source, subscriber) => {\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\n      });\n}\n"]},"metadata":{},"sourceType":"script"}