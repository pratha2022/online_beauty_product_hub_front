{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.animationFrames = void 0;\n\nvar Observable_1 = require(\"../../Observable\");\n\nvar Subscription_1 = require(\"../../Subscription\");\n\nvar performanceTimestampProvider_1 = require(\"../../scheduler/performanceTimestampProvider\");\n\nvar animationFrameProvider_1 = require(\"../../scheduler/animationFrameProvider\");\n\nfunction animationFrames(timestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\nexports.animationFrames = animationFrames;\n\nfunction animationFramesFactory(timestampProvider) {\n  var schedule = animationFrameProvider_1.animationFrameProvider.schedule;\n  return new Observable_1.Observable(function (subscriber) {\n    var subscription = new Subscription_1.Subscription();\n    var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;\n    var start = provider.now();\n\n    var run = function run(timestamp) {\n      var now = provider.now();\n      subscriber.next({\n        timestamp: timestampProvider ? now : timestamp,\n        elapsed: now - start\n      });\n\n      if (!subscriber.closed) {\n        subscription.add(schedule(run));\n      }\n    };\n\n    subscription.add(schedule(run));\n    return subscription;\n  });\n}\n\nvar DEFAULT_ANIMATION_FRAMES = animationFramesFactory();","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;AAuEA,SAAgBA,eAAhB,CAAgCC,iBAAhC,EAAqE;AACnE,SAAOA,iBAAiB,GAAGC,sBAAsB,CAACD,iBAAD,CAAzB,GAA+CE,wBAAvE;AACD;;AAFDC;;AAQA,SAASF,sBAAT,CAAgCD,iBAAhC,EAAqE;AAC3D,cAAQ,GAAKI,gDAAsBC,QAAnC;AACR,SAAO,IAAIC,uBAAJ,CAAuD,UAACC,UAAD,EAAW;AACvE,QAAMC,YAAY,GAAG,IAAIC,2BAAJ,EAArB;AAIA,QAAMC,QAAQ,GAAGV,iBAAiB,IAAIW,2DAAtC;AAKA,QAAMC,KAAK,GAAGF,QAAQ,CAACG,GAAT,EAAd;;AACA,QAAMC,GAAG,GAAG,SAANA,GAAM,CAACC,SAAD,EAAwC;AAQlD,UAAMF,GAAG,GAAGH,QAAQ,CAACG,GAAT,EAAZ;AACAN,gBAAU,CAACS,IAAX,CAAgB;AACdD,iBAAS,EAAEf,iBAAiB,GAAGa,GAAH,GAASE,SADvB;AAEdE,eAAO,EAAEJ,GAAG,GAAGD;AAFD,OAAhB;;AAIA,UAAI,CAACL,UAAU,CAACW,MAAhB,EAAwB;AACtBV,oBAAY,CAACW,GAAb,CAAiBd,QAAQ,CAACS,GAAD,CAAzB;AACD;AACF,KAhBD;;AAiBAN,gBAAY,CAACW,GAAb,CAAiBd,QAAQ,CAACS,GAAD,CAAzB;AACA,WAAON,YAAP;AACD,GA9BM,CAAP;AA+BD;;AAMD,IAAMN,wBAAwB,GAAGD,sBAAsB,EAAvD","names":["animationFrames","timestampProvider","animationFramesFactory","DEFAULT_ANIMATION_FRAMES","exports","animationFrameProvider_1","schedule","Observable_1","subscriber","subscription","Subscription_1","provider","performanceTimestampProvider_1","start","now","run","timestamp","next","elapsed","closed","add"],"sources":["/media/bytes-pratha/workspaces/projects/online_beauty_product_hub_front/node_modules/rxjs/src/internal/observable/dom/animationFrames.ts"],"sourcesContent":["import { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  const { schedule } = animationFrameProvider;\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    const subscription = new Subscription();\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n    const run = (timestamp: DOMHighResTimeStamp | number) => {\n      // Use the provider's timestamp to calculate the elapsed time. Note that\n      // this means - if the caller hasn't passed a provider - that\n      // performance.now() will be used instead of the timestamp that was\n      // passed to the run callback. The reason for this is that the timestamp\n      // passed to the callback can be earlier than the start time, as it\n      // represents the time at which the browser decided it would render any\n      // queued frames - and that time can be earlier the captured start time.\n      const now = provider.now();\n      subscriber.next({\n        timestamp: timestampProvider ? now : timestamp,\n        elapsed: now - start,\n      });\n      if (!subscriber.closed) {\n        subscription.add(schedule(run));\n      }\n    };\n    subscription.add(schedule(run));\n    return subscription;\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n"]},"metadata":{},"sourceType":"script"}